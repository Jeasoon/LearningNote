# 注册Jni方法

[TOC]

*    运行环境Android Studio
*   cmake方式构建

### 1. 常规方式

#### 1.1 编辑java源代码

#####  1.1.1 编写加载lib库

* 加载lib库, 库的名字不要添加lib文件的前缀`lib`和后缀`.so/.dll`, 在使用任何`native`方法前必须加载过动态库

```java
static {
	System.loadLibrary("myJni");
}
```

#####  1.1.2 定义native方法

* 编写native方法, 返回值前面添加`native`关键字, 表明为C++实现, 不需要方法体; 可以添加`static`, 代表为静态方法

```java
native String nativeHello();

static native String nativeWorld();
```

#####  1.1.3 编写调用方法

* 与正常的调用方式一样

```java
new MyJni().nativeHello();
nativeWorld();
```

#####  1.1.4 整体文件如下

```java
package com.jeasoon.jni;

import java.util.Locale;

public class MyJni {

    static {
        System.loadLibrary("myJni");
    }

    native String nativeHello();

    static native String nativeWorld();

    static native String nativeWorld(String args);

    public static void logHelloWorld() {
        System.out.println(String.format(Locale.ENGLISH, "%s %s", new MyJni().nativeHello(), nativeWorld()));
    }

}
```

#### 1.2 生成`.h`头文件

##### 1.2.1 编译java文件为class文件

* 编译java文件为class文件, 编译后的class放置到build目录下, 具体目录为build/com/jeasoon/jni/MyJni.class
* 编译命令如下

```shell
javac -d build src/com/jeasoon/jni/MyJni.java
```

##### 1.2.2 生成`.h`头文件

```shell
# 首先进入build目录, class全限定名的根目录
cd build
# 指定生成路径和class的全限定名
javah -jni -d ../src/cpp com.jeasoon.jni.MyJni
```

##### 1.2.3 查看生成的`.h`头文件

* `#include <jni.h>`引入jni头文件, 不然`JNIEXPORT`, `jstring`, `JNICALL`, `JNIEnv`, `jobject`,`jclass`都会找不到
* `#ifdef __cplusplus ... #endif`表明当前编译方式为c++
* `extern "C" { ... }`标识下列代码以C的方式编译, 主要区别在C++有函数重载, C没有
* 函数名规则: 前缀一般为`Java_包_名_类名_java方法名`, 包名的`.`以`_`代替
* 参数规则: 第一个参数为`JNIEnv*`类型, 第二个参数会根据是否为静态函数而不同, 如果是静态函数, 类型为`jclass`, 代表当前Class对象, 如果是成员函数, 类型为`jobject`, 代表当前Class的实例对象

```c++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_jeasoon_jni_MyJni */

#ifndef _Included_com_jeasoon_jni_MyJni
#define _Included_com_jeasoon_jni_MyJni
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_jeasoon_jni_MyJni
 * Method:    nativeHello
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_jeasoon_jni_MyJni_nativeHello
  (JNIEnv *, jobject);

/*
 * Class:     com_jeasoon_jni_MyJni
 * Method:    nativeWorld
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_jeasoon_jni_MyJni_nativeWorld__
  (JNIEnv *, jclass);

/*
 * Class:     com_jeasoon_jni_MyJni
 * Method:    nativeWorld
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_jeasoon_jni_MyJni_nativeWorld__Ljava_lang_String_2
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
}
#endif
#endif

```

#### 1.3 编写cpp代码

##### 1.3.1 创建cpp文件并编写

* 创建`com_jeasoon_jni_MyJni.cpp`文件, 添加生成的`com_jeasoon_jni_MyJni.h`引用, 编写内容如下

```c++
#include <com_jeasoon_jni_MyJni.h>

JNIEXPORT jstring JNICALL Java_com_jeasoon_jni_MyJni_nativeHello(JNIEnv *, jobject){
    return env->NewStringUTF("hello");
}

JNIEXPORT jstring JNICALL Java_com_jeasoon_jni_MyJni_nativeWorld__(JNIEnv *, jclass){
    return env->NewStringUTF("world");
}

JNIEXPORT jstring JNICALL
    Java_com_jeasoon_jni_MyJni_nativeWorld__Ljava_lang_String_2(JNIEnv *, jclass, jstring){
        return jstring;
}
```


### 2. Jni加载时动态注册

#### 2.1 编辑Java源文件

具体步骤同 1.1

#### 2.2 创建`.cpp`文件并编写

这里为了简便省略了创建`.h`文件, 正式编码时建议写`.h`

##### 2.2.1 引入`jni.h`头文件, 定义宏

```c++
#include <jni.h>

#define JAVA_CLASS_COM_JEASOON_JNI_MYJNI "com/jeasoon/jni/MyJni"
```

##### 2.2.2 声明并定义函数

*   定义函数符合c++要求即可, 不必遵循Java命名机制

```c++
jstring get_hello(JNIEnv *env, jobject obj) {
    return env->NewStringUTF("hello");
}

jstring get_world(JNIEnv *jniEnv, jclass clazz) {
    return jniEnv->NewStringUTF("world");
}

jstring get_hello_world(JNIEnv *jniEnv, jclass clazz, jstring helloworld) {
    return helloworld;
}
```

##### 2.2.3 准备注册用的数据

```c++
// 结构体JNINativeMethod的数组
// 结构体JNINativeMethod包含java的函数名, 参数列表, 本地函数指针
JNINativeMethod JNI_NATIVE_METHOD[] = {
        {"nativeHello", "()Ljava/lang/String;", (void *) get_hello},
        {"nativeWorld", "()Ljava/lang/String;", (void *) get_world}
};

// 注册函数
int register_native_method(JNIEnv *jniEnv) {
    jclass jclazz;
    // 先找到对应的jclass对象
    if (!(jclazz = jniEnv->FindClass(JAVA_CLASS_COM_JEASOON_JNI_MYJNI))) {
        return -1;
    }
    // 使用JNIEnv进行注册, 参数为jclass对象, JNINativeMethod的数组, 以及数组的长度
    if (jniEnv->RegisterNatives(jclazz, JNI_NATIVE_METHOD,
                                sizeof(JNI_NATIVE_METHOD) / sizeof(JNINativeMethod)) < 0) {
        return -1;
    }
    return JNI_OK;
}
```

##### 2.2.3 监听lib库加载并执行注册

*   在加载lib库时, 会自动调用`JNI_OnLoad`函数, 此时可以执行函数注册

```c++
extern "C" JNIEXPORT void JNICALL JNI_OnLoad(JavaVM *vm, void *unused) {
    // 先从JavaVM获取JNIEnv对象
    JNIEnv *jniEnv;
    if (vm->GetEnv(reinterpret_cast<void **>(&jniEnv), JNI_VERSION_1_6) != JNI_OK) {
        return -1;
    }
    // 执行函数注册
    register_native_method(jniEnv);
}
```

##### 2.2.4 整体文件如下

```c++
#include <jni.h>

#define JAVA_CLASS_COM_JEASOON_JNI_MYJNI "com/jeasoon/jni/MyJni"

jstring get_hello(JNIEnv *env, jobject obj) {
    return env->NewStringUTF("hello");
}

jstring get_world(JNIEnv *jniEnv, jclass clazz) {
    return jniEnv->NewStringUTF("world");
}

JNINativeMethod JNI_NATIVE_METHOD[] = {
        {"nativeHello", "()Ljava/lang/String;", (void *) get_hello},
        {"nativeWorld", "()Ljava/lang/String;", (void *) get_world}
};

int register_native_method(JNIEnv *jniEnv) {
    jclass jclazz;
    if (!(jclazz = jniEnv->FindClass(JAVA_CLASS_COM_JEASOON_JNI_MYJNI))) {
        return -1;
    }
    if (jniEnv->RegisterNatives(jclazz, JNI_NATIVE_METHOD,
                                sizeof(JNI_NATIVE_METHOD) / sizeof(JNINativeMethod)) < 0) {
        return -1;
    }
    return JNI_OK;
}

extern "C" JNIEXPORT void JNICALL JNI_OnLoad(JavaVM *vm, void *unused) {

    JNIEnv *jniEnv;
    if (vm->GetEnv(reinterpret_cast<void **>(&jniEnv), JNI_VERSION_1_6) != JNI_OK) {
        return -1;
    }
    register_native_method(jniEnv);
}

```